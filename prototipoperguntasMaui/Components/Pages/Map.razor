@page "/map"
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using Microsoft.Maui
@using Microsoft.Maui.Controls
@using Microsoft.Maui.ApplicationModel
@using Microsoft.Maui.Devices.Sensors
@using prototipoperguntasMaui.Services
@inject IJSRuntime JS
@inject AppStateService AppState
@inject NavigationManager Nav
@using Microsoft.Maui.Media
@using System.IO
@inherits ComponentBase

<div class="mobile-container map-fullscreen">
    <header
        class="bg-slate-900 text-white px-5 py-4 sticky top-0 z-50 shadow-xl rounded-b-3xl mx-[-1px] safe-top pt-[40px] map-header">
        <div class="flex justify-between items-center">
            <button class="bg-white/10 text-xs text-white px-3 py-1.5 rounded-md" @onclick="BackToDashboard">
                <i class="fa-solid fa-left-long"></i> Voltar
            </button>
            <div class="flex justify-between items-center pt-3">
                <div class="flex items-center justify-end gap-3">
                    @if (IsWatching)
                    {
                        <div
                            class="text-[9px] font-bold flex items-center gap-2 bg-green-500/10 text-green-400 px-3 py-1.5 rounded-md rounded-full border border-green-500/20">
                            <div class="w-1.5 h-1.5 text-xs px-3 py-1.5 rounded-full bg-green-400 animate-pulse"></div>
                            Localizando
                        </div>
                    }
                    else
                    {
                        <button
                            class="ml-2 text-xs font-bold bg-white/10 text-white px-3 py-1.5 rounded-mdborder border-white/10 hover:bg-white/20 transition"
                            @onclick="StartLocateAsync">
                            Tentar localizar
                        </button>

                    }
                </div>
            </div>
        </div>
    </header>

    <div id="map" class="map-canvas"></div>
</div>

@code {
    private bool _init;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_init) return;
        _init = true;

        var pdvs = AppState.Stores.Select(s => new { id = s.Id, lat = s.Lat, lng = s.Lng, label = s.Name }).ToArray();
        var user = await JS.InvokeAsync<object>("mapInterop.getUserPosition");

        // Default center: use first PDV if available, otherwise fallback to 0,0 to ensure variable is always assigned
        double[] center = pdvs.Length > 0 ? new[] { pdvs[0].lat, pdvs[0].lng } : new[] { 0.0, 0.0 };
        if (user != null)
        {
            var d = (dynamic)user;
            center = new double[] { Convert.ToDouble(d.lat), Convert.ToDouble(d.lng) };
        }

        _dotRef = DotNetObjectReference.Create(this);
        var userInfo = AppState.Meta?.User != null ? new { uuid = AppState.Meta.User.Uuid, name = AppState.Meta.User.Name } :
        null;
        await JS.InvokeVoidAsync("mapInterop.init", center, pdvs, 13, user != null, _dotRef, userInfo);

        await StartLocateAsync();

    }

    // Hold a reference so we can dispose it when component is disposed
    private DotNetObjectReference<Map>? _dotRef;

    private async Task BackToDashboard() => await Microsoft.Maui.Controls.Shell.Current.GoToAsync("..", true);

    private bool IsWatching = false;
    private CancellationTokenSource? _cts;

    // Start locating (extracted so we can auto-start on render)
    private async Task StartLocateAsync()
    {
        if (IsWatching) return;

        // Check and request location permission
        var status = await Permissions.CheckStatusAsync<Permissions.LocationWhenInUse>();
        if (status != PermissionStatus.Granted)
        {
            status = await Permissions.RequestAsync<Permissions.LocationWhenInUse>();
        }

        if (status != PermissionStatus.Granted)
        {
            // Open app settings to let user enable permission
            try { await MainThread.InvokeOnMainThreadAsync(async () => await Shell.Current.DisplayAlert("Permissão", "Permissão de localização negada. Por favor ative nas configurações do aplicativo.", "OK")); } catch { }
            try { AppInfo.ShowSettingsUI(); } catch { }
            return;
        }

        // Start a background poller to update location periodically using MAUI Geolocation
        _cts = new CancellationTokenSource();
        var token = _cts.Token;
        _ = Task.Run(async () =>
        {
            try
            {
                while (!token.IsCancellationRequested)
                {
                    try
                    {
                        var req = new GeolocationRequest(GeolocationAccuracy.Best, TimeSpan.FromSeconds(5));
                        var location = await Geolocation.Default.GetLocationAsync(req, token);
                        if (location != null)
                        {
                            await JS.InvokeVoidAsync("mapInterop.setUserMarker", location.Latitude, location.Longitude, false);
                        }
                    }
                    catch (OperationCanceledException) { break; }
                    catch { /* ignore transient GPS errors */ }

                    await Task.Delay(3000, token);
                }
            }
            catch (TaskCanceledException) { }
        }, token);

        // Also attempt an immediate one-off location to center map
        try
        {
            var quick = await Geolocation.Default.GetLocationAsync(new GeolocationRequest(GeolocationAccuracy.Best,
            TimeSpan.FromSeconds(10)));
            if (quick != null)
            {
                await JS.InvokeVoidAsync("mapInterop.setUserMarker", quick.Latitude, quick.Longitude, true);
                await JS.InvokeVoidAsync("mapInterop.centerOnUser");
            }
        }
        catch { }

        // Keep JS watch as fallback (in case in-browser geolocation is available)
        await JS.InvokeVoidAsync("mapInterop.watchUserPosition");
        IsWatching = true;
        StateHasChanged();
    }

    private async Task StopLocateAsync()
    {
        if (!IsWatching) return;
        try { _cts?.Cancel(); } catch { }
        _cts?.Dispose();
        _cts = null;

        await JS.InvokeVoidAsync("mapInterop.stopWatchUserPosition");
        IsWatching = false;
        StateHasChanged();
    }

    private async Task ToggleLocate()
    {
        if (IsWatching) await StopLocateAsync(); else await StartLocateAsync();
    }

    public async ValueTask DisposeAsync()
    {
        try { _cts?.Cancel(); } catch { }
        _cts?.Dispose();
        _cts = null;
        await JS.InvokeVoidAsync("mapInterop.stopWatchUserPosition");

        // Dispose managed DotNet reference
        try { _dotRef?.Dispose(); } catch { }
        _dotRef = null;
    }

    // Called from JS when a PDV popup 'Abrir questionário' is clicked
    [JSInvokable]
    public async Task Pdv_OpenQuestionnaire(int storeId)
    {
        try
        {
            // Diagnostic: log reception
            await JS.InvokeVoidAsync("console.log", "Pdv_OpenQuestionnaire called", storeId);

            // Invoke on MainThread because we will use MediaPicker (platform specific) and Navigation
            await MainThread.InvokeOnMainThreadAsync(async () =>
            {
                await StartStoreFromMap(storeId);
            });
        }
        catch (Exception ex)
        {
            // Forward any error to JS console for easier debugging
            try { await JS.InvokeVoidAsync("console.error", "Pdv_OpenQuestionnaire failed", ex?.Message ?? ex?.ToString()); }
            catch
            { }
            // throw; // Don't throw to JS, just log
        }
    }

    private async Task StartStoreFromMap(int storeId)
    {
        var store = AppState.Stores.FirstOrDefault(s => s.Id == storeId);
        if (store == null)
        {
            await Shell.Current.DisplayAlert("Atenção", "Loja não encontrada!", "OK");
            return;
        }

        if (store.Status == "REALIZADO" || store.Status == "SYNCED")
        {
            await Shell.Current.DisplayAlert("Atenção", "Esta visita já foi realizada.", "OK");
            return;
        }

        if (store.Status == "EM_ANDAMENTO")
        {
            AppState.ResumeVisit(store.Id);
            Nav.NavigateTo($"/store/{store.Id}");
            return;
        }

        AppState.PrepareCheckin(store.Id);

        try
        {
            var permission = await Permissions.RequestAsync<Permissions.Camera>();
            if (permission != PermissionStatus.Granted)
            {
                await Shell.Current.DisplayAlert("Permissão", "Permissão de câmera negada.", "OK");
                return;
            }

            if (!MediaPicker.Default.IsCaptureSupported)
            {
                await Shell.Current.DisplayAlert("Erro", "Captura de câmera não suportada neste dispositivo.", "OK");
                return;
            }

            var photo = await MediaPicker.Default.CapturePhotoAsync(new MediaPickerOptions
            {
                Title = "Foto da Fachada"
            });

            if (photo == null)
            {
                await Shell.Current.DisplayAlert("Atenção", "É necessário tirar uma foto para iniciar a visita.", "OK");
                return;
            }

            using var stream = await photo.OpenReadAsync();
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var base64 = Convert.ToBase64String(ms.ToArray());

            // Format data URL properly
            var dataUrl = $"data:{photo.ContentType};base64,{base64}";

            AppState.CompleteCheckin(store.Id, dataUrl);
            Nav.NavigateTo($"/store/{store.Id}");
        }
        catch (Exception ex)
        {
            await Shell.Current.DisplayAlert("Erro", $"Erro ao abrir câmera: {ex.Message}", "OK");
        }
    }
}